"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var job_main_exports = {};
__export(job_main_exports, {
  runProcess: () => runProcess
});
module.exports = __toCommonJS(job_main_exports);
var getImportMetaUrl = () => typeof document === "undefined" ? new URL(`file:${__filename}`).href : document.currentScript && document.currentScript.src || new URL("main.js", document.baseURI).href;
var importMetaUrl = /* @__PURE__ */ getImportMetaUrl();
var import_rtc_node = require("@livekit/rtc-node");
var import_node_child_process = require("node:child_process");
var import_node_events = require("node:events");
var import_node_url = require("node:url");
var import_generator = require("../generator.cjs");
var import_job = require("../job.cjs");
var import_job2 = require("../job.cjs");
var import_log = require("../log.cjs");
var import_worker = require("../worker.cjs");
const ORPHANED_TIMEOUT = 15 * 1e3;
const runProcess = (args) => {
  return (0, import_node_child_process.fork)(new URL(importMetaUrl), [args.agentFile]);
};
const startJob = (proc, func, info, closeEvent, logger) => {
  let connect = false;
  let shutdown = false;
  const room = new import_rtc_node.Room();
  room.on(import_rtc_node.RoomEvent.Disconnected, () => {
    closeEvent.emit("close", false);
  });
  const onConnect = () => {
    connect = true;
  };
  const onShutdown = (reason) => {
    shutdown = true;
    closeEvent.emit("close", true, reason);
  };
  const ctx = new import_job.JobContext(proc, info, room, onConnect, onShutdown);
  const task = new Promise(async () => {
    const unconnectedTimeout = setTimeout(() => {
      if (!(connect || shutdown)) {
        logger.warn(
          "room not connect after job_entry was called after 10 seconds, ",
          "did you forget to call ctx.connect()?"
        );
      }
    }, 1e4);
    func(ctx).finally(() => clearTimeout(unconnectedTimeout));
    await (0, import_node_events.once)(closeEvent, "close").then((close) => {
      logger.debug("shutting down");
      process.send({ case: "exiting", value: { reason: close[1] } });
    });
    await room.disconnect();
    logger.debug("disconnected from room");
    const shutdownTasks = [];
    for (const callback of ctx.shutdownCallbacks) {
      shutdownTasks.push(callback());
    }
    await Promise.all(shutdownTasks).catch(() => logger.error("error while shutting down the job"));
    process.send({ case: "done" });
    process.exit();
  });
  return { ctx, task };
};
(async () => {
  if (process.send) {
    const moduleFile = process.argv[2];
    const agent = await import((0, import_node_url.pathToFileURL)(moduleFile).pathname).then((module2) => {
      const agent2 = module2.default;
      if (agent2 === void 0 || !(0, import_generator.isAgent)(agent2)) {
        throw new Error(`Unable to load agent: Missing or invalid default export in ${moduleFile}`);
      }
      return agent2;
    });
    if (!agent.prewarm) {
      agent.prewarm = import_worker.defaultInitializeProcessFunc;
    }
    process.on("SIGINT", () => {
    });
    await (0, import_node_events.once)(process, "message").then(([msg]) => {
      msg = msg;
      if (msg.case !== "initializeRequest") {
        throw new Error("first message must be InitializeRequest");
      }
      (0, import_log.initializeLogger)(msg.value.loggerOptions);
    });
    const proc = new import_job2.JobProcess();
    let logger = (0, import_log.log)().child({ pid: proc.pid });
    logger.debug("initializing job runner");
    agent.prewarm(proc);
    logger.debug("job runner initialized");
    process.send({ case: "initializeResponse" });
    let job = void 0;
    const closeEvent = new import_node_events.EventEmitter();
    const orphanedTimeout = setTimeout(() => {
      logger.warn("process orphaned, shutting down");
      process.exit();
    }, ORPHANED_TIMEOUT);
    process.on("message", (msg) => {
      switch (msg.case) {
        case "pingRequest": {
          orphanedTimeout.refresh();
          process.send({
            case: "pongResponse",
            value: { lastTimestamp: msg.value.timestamp, timestamp: Date.now() }
          });
          break;
        }
        case "startJobRequest": {
          if (job) {
            throw new Error("job task already running");
          }
          logger = logger.child({ jobID: msg.value.runningJob.job.id });
          job = startJob(proc, agent.entry, msg.value.runningJob, closeEvent, logger);
          logger.debug("job started");
          break;
        }
        case "shutdownRequest": {
          if (!job) {
            break;
          }
          closeEvent.emit("close", "");
        }
      }
    });
  }
})();
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  runProcess
});
//# sourceMappingURL=job_main.cjs.map