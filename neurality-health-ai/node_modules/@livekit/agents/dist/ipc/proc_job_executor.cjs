"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var proc_job_executor_exports = {};
__export(proc_job_executor_exports, {
  ProcJobExecutor: () => ProcJobExecutor
});
module.exports = __toCommonJS(proc_job_executor_exports);
var import_node_events = require("node:events");
var import_log = require("../log.cjs");
var import_utils = require("../utils.cjs");
var import_job_executor = require("./job_executor.cjs");
class ProcJobExecutor extends import_job_executor.JobExecutor {
  #opts;
  #started = false;
  #closing = false;
  #runningJob = void 0;
  #proc;
  #pingInterval;
  #pongTimeout;
  #init = new import_utils.Future();
  #join = new import_utils.Future();
  #logger = (0, import_log.log)().child({ runningJob: this.#runningJob });
  constructor(agent, initializeTimeout, closeTimeout) {
    super();
    this.#opts = {
      agent,
      initializeTimeout,
      closeTimeout
    };
  }
  get started() {
    return this.#started;
  }
  get runningJob() {
    return this.#runningJob;
  }
  async start() {
    if (this.#started) {
      throw new Error("runner already started");
    } else if (this.#closing) {
      throw new Error("runner is closed");
    }
    this.#proc = await import("./job_main.cjs").then(
      (m) => m.runProcess({
        agentFile: this.#opts.agent
      })
    );
    this.#started = true;
    this.run();
  }
  async run() {
    await this.#init.await;
    this.#pingInterval = setInterval(() => {
      this.#proc.send({ case: "pingRequest", value: { timestamp: Date.now() } });
    }, this.PING_INTERVAL);
    this.#pongTimeout = setTimeout(() => {
      this.#logger.warn("job is unresponsive");
      clearTimeout(this.#pongTimeout);
      clearInterval(this.#pingInterval);
      this.#proc.kill();
      this.#join.resolve();
    }, this.PING_TIMEOUT);
    const listener = (msg) => {
      var _a;
      switch (msg.case) {
        case "pongResponse": {
          const delay = Date.now() - msg.value.timestamp;
          if (delay > this.HIGH_PING_THRESHOLD) {
            this.#logger.child({ delay }).warn("job executor is unresponsive");
          }
          (_a = this.#pongTimeout) == null ? void 0 : _a.refresh();
          break;
        }
        case "exiting": {
          this.#logger.child({ reason: msg.value.reason }).debug("job exiting");
          break;
        }
        case "done": {
          this.#closing = true;
          this.#proc.off("message", listener);
          this.#join.resolve();
          break;
        }
      }
    };
    this.#proc.on("message", listener);
    this.#proc.on("error", (err) => {
      if (this.#closing) return;
      this.#logger.child({ err }).warn("job process exited unexpectedly; this likely means the error above caused a crash");
      clearTimeout(this.#pongTimeout);
      clearInterval(this.#pingInterval);
      this.#join.resolve();
    });
    await this.#join.await;
  }
  async join() {
    if (!this.#started) {
      throw new Error("runner not started");
    }
    await this.#join.await;
  }
  async initialize() {
    const timer = setTimeout(() => {
      const err = new Error("runner initialization timed out");
      this.#init.reject(err);
      throw err;
    }, this.#opts.initializeTimeout);
    this.#proc.send({ case: "initializeRequest", value: { loggerOptions: import_log.loggerOptions } });
    await (0, import_node_events.once)(this.#proc, "message").then(([msg]) => {
      clearTimeout(timer);
      if (msg.case !== "initializeResponse") {
        throw new Error("first message must be InitializeResponse");
      }
    });
    this.#init.resolve();
  }
  async close() {
    if (!this.#started) {
      return;
    }
    this.#closing = true;
    if (!this.#runningJob) {
      this.#proc.kill();
      this.#join.resolve();
    }
    this.#proc.send({ case: "shutdownRequest" });
    const timer = setTimeout(() => {
      this.#logger.error("job shutdown is taking too much time");
    }, this.#opts.closeTimeout);
    await this.#join.await.then(() => {
      clearTimeout(timer);
      clearTimeout(this.#pongTimeout);
      clearInterval(this.#pingInterval);
    });
  }
  async launchJob(info) {
    if (this.#runningJob) {
      throw new Error("executor already has a running job");
    }
    this.#runningJob = info;
    this.#proc.send({ case: "startJobRequest", value: { runningJob: info } });
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ProcJobExecutor
});
//# sourceMappingURL=proc_job_executor.cjs.map