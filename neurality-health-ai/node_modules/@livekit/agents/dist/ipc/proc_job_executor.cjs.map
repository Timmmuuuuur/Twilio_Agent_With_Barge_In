{"version":3,"sources":["../../src/ipc/proc_job_executor.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2024 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport type { ChildProcess } from 'node:child_process';\nimport { once } from 'node:events';\nimport type { RunningJobInfo } from '../job.js';\nimport { log, loggerOptions } from '../log.js';\nimport { Future } from '../utils.js';\nimport type { ProcOpts } from './job_executor.js';\nimport { JobExecutor } from './job_executor.js';\nimport type { IPCMessage } from './message.js';\n\nexport class ProcJobExecutor extends JobExecutor {\n  #opts: ProcOpts;\n  #started = false;\n  #closing = false;\n  #runningJob?: RunningJobInfo = undefined;\n  #proc?: ChildProcess;\n  #pingInterval?: ReturnType<typeof setInterval>;\n  #pongTimeout?: ReturnType<typeof setTimeout>;\n  #init = new Future();\n  #join = new Future();\n  #logger = log().child({ runningJob: this.#runningJob });\n\n  constructor(agent: string, initializeTimeout: number, closeTimeout: number) {\n    super();\n    this.#opts = {\n      agent,\n      initializeTimeout,\n      closeTimeout,\n    };\n  }\n\n  get started(): boolean {\n    return this.#started;\n  }\n\n  get runningJob(): RunningJobInfo | undefined {\n    return this.#runningJob;\n  }\n\n  async start() {\n    if (this.#started) {\n      throw new Error('runner already started');\n    } else if (this.#closing) {\n      throw new Error('runner is closed');\n    }\n\n    this.#proc = await import('./job_main.js').then((m) =>\n      m.runProcess({\n        agentFile: this.#opts.agent,\n      }),\n    );\n\n    this.#started = true;\n    this.run();\n  }\n\n  async run() {\n    await this.#init.await;\n\n    this.#pingInterval = setInterval(() => {\n      this.#proc!.send({ case: 'pingRequest', value: { timestamp: Date.now() } });\n    }, this.PING_INTERVAL);\n\n    this.#pongTimeout = setTimeout(() => {\n      this.#logger.warn('job is unresponsive');\n      clearTimeout(this.#pongTimeout);\n      clearInterval(this.#pingInterval);\n      this.#proc!.kill();\n      this.#join.resolve();\n    }, this.PING_TIMEOUT);\n\n    const listener = (msg: IPCMessage) => {\n      switch (msg.case) {\n        case 'pongResponse': {\n          const delay = Date.now() - msg.value.timestamp;\n          if (delay > this.HIGH_PING_THRESHOLD) {\n            this.#logger.child({ delay }).warn('job executor is unresponsive');\n          }\n          this.#pongTimeout?.refresh();\n          break;\n        }\n        case 'exiting': {\n          this.#logger.child({ reason: msg.value.reason }).debug('job exiting');\n          break;\n        }\n        case 'done': {\n          this.#closing = true;\n          this.#proc!.off('message', listener);\n          this.#join.resolve();\n          break;\n        }\n      }\n    };\n    this.#proc!.on('message', listener);\n    this.#proc!.on('error', (err) => {\n      if (this.#closing) return;\n      this.#logger\n        .child({ err })\n        .warn('job process exited unexpectedly; this likely means the error above caused a crash');\n      clearTimeout(this.#pongTimeout);\n      clearInterval(this.#pingInterval);\n      this.#join.resolve();\n    });\n\n    await this.#join.await;\n  }\n\n  async join() {\n    if (!this.#started) {\n      throw new Error('runner not started');\n    }\n\n    await this.#join.await;\n  }\n\n  async initialize() {\n    const timer = setTimeout(() => {\n      const err = new Error('runner initialization timed out');\n      this.#init.reject(err);\n      throw err;\n    }, this.#opts.initializeTimeout);\n    this.#proc!.send({ case: 'initializeRequest', value: { loggerOptions } });\n    await once(this.#proc!, 'message').then(([msg]: IPCMessage[]) => {\n      clearTimeout(timer);\n      if (msg!.case !== 'initializeResponse') {\n        throw new Error('first message must be InitializeResponse');\n      }\n    });\n    this.#init.resolve();\n  }\n\n  async close() {\n    if (!this.#started) {\n      return;\n    }\n    this.#closing = true;\n\n    if (!this.#runningJob) {\n      this.#proc!.kill();\n      this.#join.resolve();\n    }\n\n    this.#proc!.send({ case: 'shutdownRequest' });\n\n    const timer = setTimeout(() => {\n      this.#logger.error('job shutdown is taking too much time');\n    }, this.#opts.closeTimeout);\n    await this.#join.await.then(() => {\n      clearTimeout(timer);\n      clearTimeout(this.#pongTimeout);\n      clearInterval(this.#pingInterval);\n    });\n  }\n\n  async launchJob(info: RunningJobInfo) {\n    if (this.#runningJob) {\n      throw new Error('executor already has a running job');\n    }\n    this.#runningJob = info;\n    this.#proc!.send({ case: 'startJobRequest', value: { runningJob: info } });\n  }\n}\n"],"mappings":"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","names":[]}