{"version":3,"sources":["../../src/stt/stream_adapter.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2024 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport type { AudioFrame } from '@livekit/rtc-node';\nimport type { VAD, VADStream } from '../vad.js';\nimport { VADEventType } from '../vad.js';\nimport type { SpeechEvent } from './stt.js';\nimport { STT, SpeechEventType, SpeechStream } from './stt.js';\n\nexport class StreamAdapter extends STT {\n  #stt: STT;\n  #vad: VAD;\n  label: string;\n\n  constructor(stt: STT, vad: VAD) {\n    super({ streaming: true, interimResults: false });\n    this.#stt = stt;\n    this.#vad = vad;\n    this.label = `stt.StreamAdapter<${this.#stt.label}>`;\n\n    this.#stt.on(SpeechEventType.METRICS_COLLECTED, (metrics) => {\n      this.emit(SpeechEventType.METRICS_COLLECTED, metrics);\n    });\n  }\n\n  _recognize(frame: AudioFrame): Promise<SpeechEvent> {\n    return this.#stt.recognize(frame);\n  }\n\n  stream(): StreamAdapterWrapper {\n    return new StreamAdapterWrapper(this.#stt, this.#vad);\n  }\n}\n\nexport class StreamAdapterWrapper extends SpeechStream {\n  #stt: STT;\n  #vadStream: VADStream;\n  label: string;\n\n  constructor(stt: STT, vad: VAD) {\n    super(stt);\n    this.#stt = stt;\n    this.#vadStream = vad.stream();\n    this.label = `stt.StreamAdapterWrapper<${this.#stt.label}>`;\n\n    this.#run();\n  }\n\n  async monitorMetrics() {\n    return; // do nothing\n  }\n\n  async #run() {\n    const forwardInput = async () => {\n      for await (const input of this.input) {\n        if (input === SpeechStream.FLUSH_SENTINEL) {\n          this.#vadStream.flush();\n        } else {\n          this.#vadStream.pushFrame(input);\n        }\n      }\n      this.#vadStream.endInput();\n    };\n\n    const recognize = async () => {\n      for await (const ev of this.#vadStream) {\n        switch (ev.type) {\n          case VADEventType.START_OF_SPEECH:\n            this.output.put({ type: SpeechEventType.START_OF_SPEECH });\n            break;\n          case VADEventType.END_OF_SPEECH:\n            this.output.put({ type: SpeechEventType.END_OF_SPEECH });\n\n            const event = await this.#stt.recognize(ev.frames);\n            if (!event.alternatives![0].text) {\n              continue;\n            }\n\n            this.output.put(event);\n            break;\n        }\n      }\n    };\n\n    Promise.all([forwardInput(), recognize()]);\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA,iBAA6B;AAE7B,iBAAmD;AAE5C,MAAM,sBAAsB,eAAI;AAAA,EACrC;AAAA,EACA;AAAA,EACA;AAAA,EAEA,YAAY,KAAU,KAAU;AAC9B,UAAM,EAAE,WAAW,MAAM,gBAAgB,MAAM,CAAC;AAChD,SAAK,OAAO;AACZ,SAAK,OAAO;AACZ,SAAK,QAAQ,qBAAqB,KAAK,KAAK,KAAK;AAEjD,SAAK,KAAK,GAAG,2BAAgB,mBAAmB,CAAC,YAAY;AAC3D,WAAK,KAAK,2BAAgB,mBAAmB,OAAO;AAAA,IACtD,CAAC;AAAA,EACH;AAAA,EAEA,WAAW,OAAyC;AAClD,WAAO,KAAK,KAAK,UAAU,KAAK;AAAA,EAClC;AAAA,EAEA,SAA+B;AAC7B,WAAO,IAAI,qBAAqB,KAAK,MAAM,KAAK,IAAI;AAAA,EACtD;AACF;AAEO,MAAM,6BAA6B,wBAAa;AAAA,EACrD;AAAA,EACA;AAAA,EACA;AAAA,EAEA,YAAY,KAAU,KAAU;AAC9B,UAAM,GAAG;AACT,SAAK,OAAO;AACZ,SAAK,aAAa,IAAI,OAAO;AAC7B,SAAK,QAAQ,4BAA4B,KAAK,KAAK,KAAK;AAExD,SAAK,KAAK;AAAA,EACZ;AAAA,EAEA,MAAM,iBAAiB;AACrB;AAAA,EACF;AAAA,EAEA,MAAM,OAAO;AACX,UAAM,eAAe,YAAY;AAC/B,uBAAiB,SAAS,KAAK,OAAO;AACpC,YAAI,UAAU,wBAAa,gBAAgB;AACzC,eAAK,WAAW,MAAM;AAAA,QACxB,OAAO;AACL,eAAK,WAAW,UAAU,KAAK;AAAA,QACjC;AAAA,MACF;AACA,WAAK,WAAW,SAAS;AAAA,IAC3B;AAEA,UAAM,YAAY,YAAY;AAC5B,uBAAiB,MAAM,KAAK,YAAY;AACtC,gBAAQ,GAAG,MAAM;AAAA,UACf,KAAK,wBAAa;AAChB,iBAAK,OAAO,IAAI,EAAE,MAAM,2BAAgB,gBAAgB,CAAC;AACzD;AAAA,UACF,KAAK,wBAAa;AAChB,iBAAK,OAAO,IAAI,EAAE,MAAM,2BAAgB,cAAc,CAAC;AAEvD,kBAAM,QAAQ,MAAM,KAAK,KAAK,UAAU,GAAG,MAAM;AACjD,gBAAI,CAAC,MAAM,aAAc,CAAC,EAAE,MAAM;AAChC;AAAA,YACF;AAEA,iBAAK,OAAO,IAAI,KAAK;AACrB;AAAA,QACJ;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,IAAI,CAAC,aAAa,GAAG,UAAU,CAAC,CAAC;AAAA,EAC3C;AACF;","names":[]}