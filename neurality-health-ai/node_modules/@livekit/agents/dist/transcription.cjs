"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var transcription_exports = {};
__export(transcription_exports, {
  BasicTranscriptionForwarder: () => BasicTranscriptionForwarder
});
module.exports = __toCommonJS(transcription_exports);
var import_log = require("./log.cjs");
class BasicTranscriptionForwarder {
  #room;
  #participantIdentity;
  #trackSid;
  #currentText = "";
  #totalAudioDuration = 0;
  #currentPlayoutTime = 0;
  #DEFAULT_CHARS_PER_SECOND = 16;
  #charsPerSecond = this.#DEFAULT_CHARS_PER_SECOND;
  #messageId;
  #isRunning = false;
  #logger = (0, import_log.log)();
  currentCharacterIndex = 0;
  constructor(room, participantIdentity, trackSid, messageId) {
    this.#room = room;
    this.#participantIdentity = participantIdentity;
    this.#trackSid = trackSid;
    this.#messageId = messageId;
  }
  get text() {
    return this.#currentText;
  }
  start() {
    if (!this.#isRunning) {
      this.#isRunning = true;
      this.#startPublishingLoop().catch((error) => {
        this.#logger.error("Error in publishing loop:", error);
        this.#isRunning = false;
      });
    }
  }
  pushAudio(frame) {
    this.#totalAudioDuration += frame.samplesPerChannel / frame.sampleRate;
  }
  pushText(text) {
    this.#currentText += text;
  }
  #textIsComplete = false;
  #audioIsComplete = false;
  markTextComplete() {
    this.#textIsComplete = true;
    this.#adjustTimingIfBothFinished();
  }
  markAudioComplete() {
    this.#audioIsComplete = true;
    this.#adjustTimingIfBothFinished();
  }
  #adjustTimingIfBothFinished() {
    if (this.#textIsComplete && this.#audioIsComplete) {
      const actualDuration = this.#totalAudioDuration;
      if (actualDuration > 0 && this.#currentText.length > 0) {
        this.#charsPerSecond = this.#currentText.length / actualDuration;
      }
    }
  }
  #computeSleepInterval() {
    return Math.min(Math.max(1 / this.#charsPerSecond, 0.0625), 0.5);
  }
  async #startPublishingLoop() {
    this.#isRunning = true;
    let sleepInterval = this.#computeSleepInterval();
    let isComplete = false;
    while (this.#isRunning && !isComplete) {
      this.#currentPlayoutTime += sleepInterval;
      this.currentCharacterIndex = Math.floor(this.#currentPlayoutTime * this.#charsPerSecond);
      isComplete = this.#textIsComplete && this.currentCharacterIndex >= this.#currentText.length;
      await this.#publishTranscription(false);
      if (this.#isRunning && !isComplete) {
        sleepInterval = this.#computeSleepInterval();
        await new Promise((resolve) => setTimeout(resolve, sleepInterval * 1e3));
      }
    }
    if (this.#isRunning) {
      this.close(false);
    }
  }
  async #publishTranscription(final) {
    var _a;
    const textToPublish = this.#currentText.slice(0, this.currentCharacterIndex);
    await ((_a = this.#room.localParticipant) == null ? void 0 : _a.publishTranscription({
      participantIdentity: this.#participantIdentity,
      trackSid: this.#trackSid,
      segments: [
        {
          text: textToPublish,
          final,
          id: this.#messageId,
          startTime: BigInt(0),
          endTime: BigInt(0),
          language: ""
        }
      ]
    }));
  }
  async close(interrupt) {
    this.#isRunning = false;
    if (!interrupt) {
      this.currentCharacterIndex = this.#currentText.length;
    }
    await this.#publishTranscription(true);
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  BasicTranscriptionForwarder
});
//# sourceMappingURL=transcription.cjs.map